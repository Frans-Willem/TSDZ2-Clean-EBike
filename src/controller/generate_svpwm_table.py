import math
import numpy as np

MINIMUM_PWM_PERIOD = -127*2
MAXIMUM_PWM_PERIOD = 127*2

# From degrees, get a unit vector in that direction.
def unitvector_from_degrees(deg):
    rad = math.radians(deg)
    return np.array([[math.sin(rad)], [math.cos(rad)]])

# Takes an input vector Vinput,
# two basis vectors Va and Vb,
# and outputs two scalars a and b,
# such that Vinput = a*Va + b*Vb
def change_of_basis(Vinput, Va, Vb):
    # Vinput = [Va | Vb] * [a, b]
    # [Va | Vb]^-1 * Vinput = [a,b]
    VaVb = np.concatenate([Va,Vb], axis=1)
    VaVbinv = np.linalg.inv(VaVb)
    result = VaVbinv.dot(Vinput)
    return (result[0][0], result[1][0])

# Our PWM scheme allows us to make one phase negative for a period of time,
# and one phase positive for another,
# but one has to remain zero.
# A valid basis thus has at most one negative component,
# and one positive component.
def is_valid_basis(abc):
    pos, neg = (0,0)
    for component in abc:
        if component < 0:
            neg = neg + 1
        elif component > 0:
            pos = pos + 1
    return neg<=1 and pos<=1

# Find a valid basis such that there is at most one positive,
# and at most one negative component
def find_valid_basis(Vref, Va, Vb, Vc):
    a, b = change_of_basis(Vref, Va, Vb)
    if is_valid_basis([a,b,0]):
        return [a,b,0]
    b,c = change_of_basis(Vref, Vb, Vc)
    if is_valid_basis([0, b, c]):
        return [0, b, c]
    c, a = change_of_basis(Vref, Vc, Va)
    if is_valid_basis([a, 0, c]):
        return [a, 0, c]
    return None


# Given that from our desired rotation,
# we've found a basis from the vectors of our motor coils
# that has one negative, one positive, and one zero component,
# Generate the PWM numbers for these phases.
# Note that this PWM signal still has one phase going to zero immediately,
# and the unit of the duration is not specified, and may exceed zero.
def calculate_pwm(abc):
    sorted_phases = sorted(zip(abc, range(0, 3)))
    period_accumulated = 0
    output = [0,0,0]
    for (period, phase) in sorted_phases:
        if period > 0:
            period_accumulated += period
        output[phase] = period_accumulated
        if period < 0:
            period_accumulated -= period
    return output

# For an index, calculate a valid phase basis (see is_valid_basis)
def calculate_basis(index):
    # Convert index 0-256 to degrees 0-360
    # Using 0-256 'degrees' means we can use standard uint8_t overflow,
    # instead of having to do an explicit modulo operation.
    degrees = (index / 256) * 360
    # Phase voltage should be 90 degrees ahead of rotor position,
    # Instead of doing this runtime, let's do this compile time:
    degrees = (degrees - 90) % 360
    # Calculate a unit vector in the direction of degrees, this is the resulting vector that we'd like
    Vref = unitvector_from_degrees(degrees)

    # Calculate vectors in the directions of our A, B, C poles
    Va = unitvector_from_degrees(0)
    Vb = unitvector_from_degrees(120)
    Vc = unitvector_from_degrees(240)

    return find_valid_basis(Vref, Va, Vb, Vc)

# Given three PWM periods that are uncapped,
# Cap them to the min_new_period and max_new_period,
# And in the process also center and round them.
def map_pwm(periods, min_period, max_period, min_new_period, max_new_period):
	# First map them from 0 to 1
	periods = tuple((period - min_period)/(max_period-min_period) for period in periods)
	# Then center them
	max_period_distance = max(periods)-min(periods)
	periods = tuple(period + (1-max_period_distance)/2 for period in periods)
	# Map to min-max, and round
	periods = tuple(int(round(period * (max_new_period-min_new_period) + min_new_period)) for period in periods)
	return periods


basis = map(calculate_basis, range(0, 128))
uncapped_pwm = list(map(calculate_pwm, basis))
maximum_uncapped_pwm_period = max(map(max, uncapped_pwm))
results = map(lambda pwms: map_pwm(pwms, 0, maximum_uncapped_pwm_period, MINIMUM_PWM_PERIOD, MAXIMUM_PWM_PERIOD), uncapped_pwm)
results = list(results)


print("// Generated by generate_svpwm_table.py")
print("// Do not edit by hand, instead edit the python script")
print("")
print("uint8_t ui8_svm_table[] = {")
for a,b,c in results:
	print("\t" + str(a) + ",")
print("};");

# Uncomment this to plot the output
# import matplotlib.pyplot as plt
# plt.plot(list(map(lambda pwm: pwm[0], results)))
# plt.ylabel("PWM")
# plt.show()
