import math
import numpy as np

"""
    This script generates pulse width lookup table for space vector
    pulsewidth modulation (svpwm) of a 3 phase brushless dc motor.
    See for example http://www.ti.com/lit/an/spra524/spra524.pdf
"""

MINIMUM_PWM_PERIOD = 0
MAXIMUM_PWM_PERIOD = 254

MIDDLE_PWM_PERIOD = (MINIMUM_PWM_PERIOD + MAXIMUM_PWM_PERIOD)//2
PWM_AMPLITUDE = min(MIDDLE_PWM_PERIOD - MINIMUM_PWM_PERIOD, MAXIMUM_PWM_PERIOD - MIDDLE_PWM_PERIOD)

# Some more resolution. We're already dividing by 256 after multiplying with dutycycle,
# might as well divide by 512...
PWM_AMPLITUDE *= 2

# From degrees, get a unit vector in that direction.
def unitvector_from_degrees(deg):
    rad = math.radians(deg)
    return np.array([[math.sin(rad)], [math.cos(rad)]])

# Takes an input vector Vinput,
# two basis vectors Va and Vb,
# and outputs two scalars a and b,
# such that Vinput = a*Va + b*Vb
def change_of_basis(Vinput, Va, Vb):
    # Vinput = [Va | Vb] * [a, b]
    # [Va | Vb]^-1 * Vinput = [a,b]
    VaVb = np.concatenate([Va,Vb], axis=1)
    VaVbinv = np.linalg.inv(VaVb)
    result = VaVbinv.dot(Vinput)
    return (result[0][0], result[1][0])


# compute the pwm pulse width given a given unit space vector
def pwm_pulse_width_for_space_vector(degrees):
    Vref = unitvector_from_degrees(degrees)
    sector = np.floor(degrees / 60.0);

    # length of basis vectors in hexagon
    # m = modulation index of space vector modulation
    m = 2.0 / np.sqrt(3.0)

    Va = m * unitvector_from_degrees(sector * 60)
    Vb = m * unitvector_from_degrees((sector + 1) * 60)

    a, b = change_of_basis(Vref, Va, Vb)
    # the off time is split 50/50 to the 'all transistors on'
    # and the 'all transistors off' state of the 3-phase H-bridge
    t0 = (1.0 - a - b)
    t0_2 = t0 / 2.0;
    t0_4 = t0 / 4.0;

    #print("%d %.2f %.3f %.3f %.3f" % (sector, degrees, a, b, t0))
    if sector == 0: # Va = (1 0 0), Vb = (1 1 0)
        return [a + b + t0_2, b + t0_2, t0_2]
    elif sector == 1: # Va = (1 1 0) Vb = (0 1 0)
        return [a + t0_2, a + b + t0_2, t0_2]
    elif sector == 2: # Va = (0 1 0) Vb = (0 1 1)
        return [t0_2, a + b + t0_2, b + t0_2]
    elif sector == 3: # Va = (0 1 1) Vb = (0 0 1)
        return [t0_2, a + t0_2, a + b + t0_2]
    elif sector == 4: # Va = (0 0 1) Vb = (1 0 1)
        return [b + t0_2, t0_2, a + b + t0_2]
    elif sector == 5: # Va = (1 0 1) Vb = (1 0 0 )
        return [a + b + t0_2, t0_2, a + t0_2]
    else:
        return None

# For an index, calculate a valid phase basis (see is_valid_basis)
def calculate_pwm_pulse_width(index):
    # Convert index 0-256 to degrees 0-360
    # Using 0-256 'degrees' means we can use standard uint8_t overflow,
    # instead of having to do an explicit modulo operation.
    degrees = (index / 256) * 360
    # Phase voltage should be 90 degrees ahead of rotor position,
    # Instead of doing this runtime, let's do this compile time:
    degrees = (degrees - 90) % 360
    #degrees = (degrees - 0) % 360
    # Compute the pulse width for a unit space vector with the given angle
    return pwm_pulse_width_for_space_vector(degrees)


#basis = map(calculate_basis, range(0, 75))
pulse_width_3 = map(calculate_pwm_pulse_width, range(0, 256))
# Only keep the first phase, as the second and third are just a degree shift away.
pulse_width = list(map(lambda x: x[0], pulse_width_3))
# center
pulse_width = [2 * x - 1.0 for x in pulse_width]
# scale
pulse_width = [x * MAXIMUM_PWM_PERIOD for x in pulse_width]
# Invert the last half of the results,
# First half will be added to MIDDLE_PWM_PERIOD,
# Second half will be substracted from MIDDLE_PWM_PERIOD.
pulse_width = pulse_width[0:128] + list(map(lambda x: 0-x, pulse_width[128:]))
# round and convert to integer value
pulse_width = [int(round(x)) for x in pulse_width]

print("// Generated by generate_svpwm_table.py")
print("// Do not edit by hand, instead edit the python script")
print("")
print("#define UI8_SVM_TABLE_MIDDLE", str(MIDDLE_PWM_PERIOD))
print("")
print("uint8_t ui8_svm_table[] = {")
for a in pulse_width:
    print("\t" + str(a) + ",")
print("};");


# Uncomment this to plot the output
#deg = [x * 360 / 256 for x in range(0, 256)]
#import matplotlib.pyplot as plt
#plt.plot(deg, pulse_width)
#plt.ylabel("PWM")
#plt.show()
